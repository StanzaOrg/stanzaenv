defpackage stanzaenv/harness :
  import core
  import collections
  import core/parsed-path
  import stanzaenv/download
  import stanzaenv/unzip
  import stanzaenv/urls
  import stanzaenv/system-state
  import stanzaenv/read-state
  import stanzaenv/install
  import stanzaenv/system-api
  import stanzaenv/versions
  import stanzaenv/config-syntax

;============================================================
;================ Testing System States =====================
;============================================================

defn testing-state (ints:Seqable<Int>) -> SystemState :

  val int-counter = to-seq(ints)

  defn int-switch (ctxt:String, max:Int) :
    if empty?(int-counter) :
      fatal("Expecting to receive integer switch (%_ or lower) for context %~." % [max, ctxt])
    val i = next(int-counter)
    if i > max :
      fatal("Context %~ expecting integer switch %_ or lower, but received %_." % [ctxt, max])
    ;Debugging println
    ;println("Use switch %_ for context %~." % [i, ctxt])
    i

  defn project-version () -> ProjectVersion|False :
    switch(int-switch("project-version", 2)) :
      0 : ProjectVersion(".stanza_version", version-spec())
      1 : ProjectVersion("../../.stanza_version", version-spec())
      2 : false    
      
  defn version-spec () -> VersionSpecifier :
    switch(int-switch("version-spec", 4)) :
      0 : NamedVersion([0 17 49])
      1 : NamedVersion([0 17 50])
      2 : NamedVersion([1 0 0])
      3 : LocalVersion("path/to/mybuild")
      4 : LocalVersion("../../mystanza")

  defn installation () -> EnvInstallation :
    switch(int-switch("installation", 3)) :
      0 : DefaultInstallation("/users/patricksli/.stanzaenv")
      1 : DefaultInstallation("/users/naz/.stanzaenv")
      2 : ConfigInstallation("/Applications/mystanzaenv")
      3 : NoInstallation()

  defn path-status () -> PathStatus :
    val [path, index] = switch(int-switch("path",3)) :
      0 : [[], false]
      1 : [["/users/patricksli/bin"
            "/users/patricksli/opt/local"
            "/opt/bin"]
           false]
      2 : [["/users/patricksli/bin"
            "/users/patricksli/opt/local"
            "/opt/bin"]
           1]
      3 : [["/users/naz/bin"]
           0]
    PathStatus(path, index)

  defn installed-versions () -> Tuple<InstalledStanza> :
    val n = int-switch("installed-versions", 3)
    to-tuple $ for i in 0 to n seq :
      InstalledStanza(version-spec() as NamedVersion)

  SystemState(
    project-version()
    installation()
    version-spec()
    path-status()
    installed-versions())

;============================================================
;================= Printing out System States ===============
;============================================================

defn print-states () :
  println $ testing-state $ [
    0 ;project-version
    0 ;version-spec
    0 ;installation
    0 ;version-spec
    0 ;path
    1 ;installed-versions
    2 ;version-spec
  ]

  println $ testing-state $ [
    1 ;project-version
    0 ;version-spec
    0 ;installation
    0 ;version-spec
    0 ;path
    1 ;installed-versions
    2 ;version-spec
  ]

  println $ testing-state $ [
    2 ;project-version
    0 ;installation
    0 ;version-spec
    0 ;path
    1 ;installed-versions
    2 ;version-spec
  ]

  println $ testing-state $ [
    2 ;project-version
    0 ;installation
    2 ;version-spec
    0 ;path
    1 ;installed-versions
    2 ;version-spec
  ]

  println $ testing-state $ [
    2 ;project-version
    0 ;installation
    3 ;version-spec
    0 ;path
    1 ;installed-versions
    2 ;version-spec
  ]

  println $ testing-state $ [
    2 ;project-version
    0 ;installation
    4 ;version-spec
    0 ;path
    1 ;installed-versions
    2 ;version-spec
  ]

  println $ testing-state $ [
    2 ;project-version
    0 ;installation
    4 ;version-spec
    1 ;path
    1 ;installed-versions
    2 ;version-spec
  ]

  println $ testing-state $ [
    2 ;project-version
    0 ;installation
    4 ;version-spec
    2 ;path
    1 ;installed-versions
    2 ;version-spec
  ]

  println $ testing-state $ [
    2 ;project-version
    0 ;installation
    4 ;version-spec
    3 ;path
    1 ;installed-versions
    2 ;version-spec
  ]

  println $ testing-state $ [
    2 ;project-version
    0 ;installation
    4 ;version-spec
    3 ;path
    0 ;installed-versions
  ]

  println $ testing-state $ [
    2 ;project-version
    0 ;installation
    4 ;version-spec
    3 ;path
    3 ;installed-versions
    1 ;version 0
    1 ;version 1
    2 ;version 2
  ]

;============================================================
;==================== Mock System ===========================
;============================================================

defstruct MockFile :
  contents:String

defn MockSystem (env-vars:Tuple<KeyValue<String,String>>
                 existing-files:Tuple<KeyValue<String,FileType|MockFile>>,
                 prompts:Tuple<KeyValue<String,String>>,
                 platform:Platform) -> System :
  val prompt-seq = to-seq(prompts)  
  new System :
    defmethod get-env (this, name:String) :
      val result = lookup?(env-vars, name)
      println("MockSystem: get-env(%~) = %~" % [name, result])
      result
    defmethod create-dir (this, name:String) :
      println("MockSystem: create-dir(%~)" % [name])
    defmethod file-exists? (this, name:String) :
      val result = contains?(seq(key,existing-files), name)
      println("MockSystem: file-exists?(%~) = %~" % [name, result])
      result
    defmethod directory? (this, name:String) :
      val entry = find!({key(_) == name}, existing-files)
      value(entry) is DirectoryType
    defmethod current-platform (this) :
      val result = platform
      println("MockSystem: current-platform() = %~" % [result])
      result
    defmethod download-to-file (this, url:String, filename:String) :
      println("MockSystem: download-to-file(%~, %~)" % [url, filename])
    defmethod unzip-to-folder (this, zipfile:String, folder:String) :
      println("MockSystem: unzip-to-folder(%~, %~)" % [zipfile, folder])
    defmethod delete-recursive (this, folder:String) :
      println("MockSystem: delete-recursive %~" % [folder])
    defmethod move-dir (this, oldpath:String, newpath:String) :
      println("MockSystem: move-dir(%~, %~)" % [oldpath, newpath])
    defmethod resolve-path (this, path:String) :      
      val ppath = parse-path(path)
      val result = 
        if absolute?(ppath) :
          path
        else :
          match(lookup?(env-vars, "PWD")) :
            (cwd:String) : to-string(relative-to-dir(parse-path(cwd), path))
            (f:False) : false
      println("MockSystem: resolve-path(%~) = %~" % [path, result])      
      result
    defmethod spit (this, path:String, snippet, append?:True|False) :
      println("MockSystem: spit(%~, %~)" % [path, append?])
      println("Contents:")
      within indented() :
        println(snippet)
    defmethod read-file (this, path:String) :
      println("MockSystem: read-file(%~)" % [path])
      val entry = lookup?(existing-files, path)
      match(entry:MockFile) :
        reader/read-all(contents(entry))
      else :
        throw(Exception("Failed to read %~." % [path]))
    defmethod prompt-user (this, prompt:String) :
      ;Retrieve answer from prompt sequence.
      val answer = if not empty?(prompt-seq) :
        val entry = peek(prompt-seq)
        if substring?(prompt, key(entry)) :
          next(prompt-seq)
          value(entry)
      ;Either return the answer or fatal.
      match(answer:String) :
        println("MockSystem: %_%_" % [prompt, answer])
        answer
      else :
        println("MockSystem: %_" % [prompt])
        if empty?(prompt-seq) :
          fatal("No more answers in prompt sequence.")
        else :
          fatal("Next prompt in prompt sequence expected to be about %~." % [key(next(prompt-seq))])

;============================================================
;==================== Try Out Install =======================
;============================================================

;Does not install Stanza at the end.
defn try-install-0 () :
  val sys = MockSystem(
    ;env vars
    ["SHELL" => "bin/zsh"
     "HOME" => "/users/patricksli"]
    
    ;existing files
    ["/Applications" => DirectoryType()]
    
    ;prompts
    ["installed in" => "/Applications/stanzaenv"
     "system PATH" => "yes"
     "STANZAENV_DIR" => "yes"
     "initial version of Stanza" => ""]

    ;platform
    OS-X)
    
  install-stanzaenv(sys)

;Tries to install Stanza at the end.
defn try-install-1 () :
  val sys = MockSystem(
    ;env vars
    ["SHELL" => "bin/zsh"
     "HOME" => "/users/patricksli"]
    
    ;existing files
    ["/Applications" => DirectoryType()]
    
    ;prompts
    ["installed in" => "/Applications/stanzaenv"
     "system PATH" => "yes"
     "STANZAENV_DIR" => "yes"
     "initial version of Stanza" => "0.17.52"]

    ;platform
    OS-X)
    
  install-stanzaenv(sys)

;============================================================
;================== Try parsing config file =================
;============================================================

defn print-errors (body:() -> ?) :
  try: body()
  catch (e) : println(e)

defn try-parse-config-1 () :
  val str = \<STR>
  version: "0.1"
  <STR>
  within print-errors() :
    parse-config-file(reader/read-all(str))

defn try-parse-config-2 () :
  val str = \<STR>
  stanza-version: "0.1.17"
  <STR>
  within print-errors() :
    parse-config-file(reader/read-all(str))

defn try-parse-config-3 () :
  val str = \<STR>
  stanza-version: local "mypath"
  <STR>
  within print-errors() :
    parse-config-file(reader/read-all(str))

defn try-parse-config-4 () :
  val str = \<STR>
  stanza-version: system
  <STR>
  within print-errors() :
    parse-config-file(reader/read-all(str))

;============================================================
;===================== Try Out Read State ===================
;============================================================

defn try-read-state-1 () :
  val sys = MockSystem(
    ;env vars
    ["SHELL" => "bin/zsh"
     "HOME" => "/users/patricksli"]
    
    ;existing files
    ["/Applications" => DirectoryType()]
    
    ;prompts
    ["installed in" => "/Applications/stanzaenv"
     "system PATH" => "yes"
     "STANZAENV_DIR" => "yes"
     "initial version of Stanza" => ""]

    ;platform
    OS-X)
  system-state(sys)

defn try-read-state-2 () :
  val sys = MockSystem(
    ;env vars
    ["PWD" => "/users/myworkdir"
     "SHELL" => "bin/zsh"
     "HOME" => "/users/patricksli"]
    
    ;existing files
    ["/Applications" => DirectoryType()]
    
    ;prompts
    ["installed in" => "/Applications/stanzaenv"
     "system PATH" => "yes"
     "STANZAENV_DIR" => "yes"
     "initial version of Stanza" => ""]

    ;platform
    OS-X)
  system-state(sys)

defn try-read-state-3 () :
  val global-config = \<STR>
    stanza-version: "0.17.52"
  <STR>
  val sys = MockSystem(
    ;env vars
    ["PWD" => "/users/myworkdir"
     "SHELL" => "bin/zsh"
     "HOME" => "/users/patricksli"]
    
    ;existing files
    ["/Applications" => DirectoryType()
     "/users/patricksli/.stanzaenv" => DirectoryType()
     "/users/patricksli/.stanzaenv/bin/stanzaenv" => RegularFileType()
     "/users/patricksli/.stanzaenv/stanzaenv.config" => MockFile(global-config)]
    
    ;prompts
    ["installed in" => "/Applications/stanzaenv"
     "system PATH" => "yes"
     "STANZAENV_DIR" => "yes"
     "initial version of Stanza" => ""]

    ;platform
    OS-X)
  system-state(sys)

;============================================================
;==================== Main Launcher =========================
;============================================================


  

within (package,sig) = set-stack-trace-filter() :
  package != `core
;try-parse-config-4()
try-read-state-3()
